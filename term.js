var connid;
var connected = false;
var path;
var addr = -1;
var values = [];
var plotxpos = 10;
var plotypos = [];
var wavecolor = ["white", "red", "blue", "green", "rgb(255, 128, 0)", "rgb(128, 128, 64)", "rgb(128, 64, 128)", "rgb(64, 128, 128)"];
var wavename = [];
var pixel = 1;
var txqueue = [];
var capture_active = false;
var data = "";
var grid = 50;


const NUM_GAUGES = 6;
var gauge_buf = [];
var chart_buf =[];


var g = [];

const MAX_CHART_POINTS = 300;

var wavecanvas;
var backcanvas;



var uitime = setInterval(refresh_UI, 100);

function refresh_UI(){
	var gauges =g.length;
	while(gauges){
		gauges--;
		g[gauges].refresh(gauge_buf[gauges]);
		
	}
}





hterm.defaultStorage = new lib.Storage.Memory();

const t = new hterm.Terminal();


t.onTerminalReady = function() {
  // Create a new terminal IO object and give it the foreground.
  // (The default IO object just prints warning messages about unhandled
  // things to the the JS console.)
  const io = t.io.push();

  io.onVTKeystroke = (str) => {
	chrome.serial.send(connid, convertStringToArrayBuffer(str), sendcb);
	//t.io.println(str);
    // Do something useful with str here.
    // For example, Secure Shell forwards the string onto the NaCl plugin.
  };

  io.sendString = (str) => {
	  chrome.serial.send(connid, convertStringToArrayBuffer(str), sendcb);
    // Just like a keystroke, except str was generated by the terminal itself.
    // For example, when the user pastes a string.
    // Most likely you'll do the same thing as onVTKeystroke.
  };

  io.onTerminalResize = (columns, rows) => {
    // React to size changes here.
    // Secure Shell pokes at NaCl, which eventually results in
    // some ioctls on the host.
  };

  // You can call io.push() to foreground a fresh io context, which can
  // be uses to give control of the terminal to something else.  When that
  // thing is complete, should call io.pop() to restore control to the
  // previous io object.
};




function convertArrayBufferToString(buf){
  var bufView = new Uint8Array(buf);
  var encodedString = String.fromCharCode.apply(null, bufView);
  var str = decodeURIComponent(encodedString);
  return str;
}

function convertStringToArrayBuffer(str) {
  var buf=new ArrayBuffer(str.length);
  var bufView=new Uint8Array(buf);
  for (var i=0; i<str.length; i++) {
    bufView[i]=str.charCodeAt(i);
  }
  return buf;
}

function out(txt){
   var out = document.getElementById("out");
   out.innerHTML = out.innerHTML + txt;
   out.scrollTop = out.scrollHeight;
}

function println(str){
	out('<font color="FireBrick">' + str + '</font><br/>')
}

function sendcb(info){
   //println("send " + info.bytesSent + " bytes");
   //println("error: " + info.error);
}

const TT_GAUGE = 1;
const TT_GAUGE_CONF = 2;
const TT_CHART = 3;
const TT_CHART_DRAW = 4;
const TT_CHART_CONF = 5;


const TT_STATE_IDLE = 0;
const TT_STATE_FRAME = 1
const TT_STATE_COLLECT = 3

const TT_STATE_GAUGE = 10;

var term_state=0;

var chart_cnt = 0;
var chart_scale_cnt =1;
var tterm = [{min: 0, max: 1024.0, offset: 1024.0, value: 0, name: ''}];

const DATA_TYPE = 0;
const DATA_LEN = 1;
const DATA_NUM = 2;

function compute(dat){
	switch(dat[DATA_TYPE]){
		case TT_GAUGE:
			gauge_buf[dat[DATA_NUM]]=dat[3]+(dat[4]<<8);
		break;
		case TT_GAUGE_CONF:
			var gauge_num = dat[2].valueOf();
			var gauge_min = dat[3]+(dat[4]<<8);
			var gauge_max = dat[5]+(dat[6]<<8);
			dat.splice(0,7);
			var str = convertArrayBufferToString(dat);
			g[gauge_num].refreshTitle(str);
			g[gauge_num].refresh(gauge_min,gauge_max);
		break;
		case TT_CHART_CONF:
			var chart_num = dat[2].valueOf();
			tterm[chart_num].min = dat[3]+(dat[4]<<8);
			tterm[chart_num].max = dat[5]+(dat[6]<<8);
			tterm[chart_num].offset = dat[7]+(dat[8]<<8);
			dat.splice(0,9);
			tterm[chart_num].name = convertArrayBufferToString(dat);
			redrawInfo();
			redrawMeas();
		break;		
		case TT_CHART:
			var val=dat[3]+(dat[4]<<8);
			var chart_num= dat[DATA_NUM].valueOf();
			tterm[chart_num].value=(val-tterm[chart_num].offset)/ tterm[chart_num].max;
		break;
		case TT_CHART_DRAW:
			plot();
		break;
		
	}
}

var buffer = [];
var bytes_done = 0;


function receive(info){

  

	var buf = new Uint8Array(info.data);
	var txt = '';
	
	for (var i = 0; i < buf.length; i++) {
		
			
		switch(term_state){
			case TT_STATE_IDLE:
				if(buf[i]== 0xff){
					term_state = TT_STATE_FRAME;
				}else{
					var str = String.fromCharCode.apply(null, [buf[i]]);
					t.io.print(str);
				}
			break;
				
			case TT_STATE_FRAME:
				buffer[DATA_LEN]=buf[i];
				bytes_done=0;
				term_state=TT_STATE_COLLECT;
			break;
			
			case TT_STATE_COLLECT:
				
				if(bytes_done==0){
					buffer[0] = buf[i];
					bytes_done++;
					break;
				}else{
					
					if(bytes_done<buffer[DATA_LEN]-1){
						buffer[bytes_done+1]=buf[i]
						bytes_done++;
					}else{
						buffer[bytes_done+1]=buf[i];
						bytes_done=0;
						term_state=TT_STATE_IDLE;
						compute(buffer);
						buffer=[];
					}
				}
				
			break;
	

		}
	}
}

function connected_cb(connectionInfo){
	if(connectionInfo.connectionId){
   	t.io.println("connected");
   	connid = connectionInfo.connectionId;
		connected = true;
		w2ui['toolbar'].get('connect').text = 'Disconnect';
		w2ui['toolbar'].refresh();
		send_command('stmbl start\rcls\r');
		
	}
};

function getdevs(devices){
   for (var i = 0; i < devices.length; i++) {
      if((devices[i].displayName && devices[i].displayName.indexOf("STMBL") > -1) || (devices[i].vendorId && devices[i].vendorId == 1204 && devices[i].productId && devices[i].productId == 62002)){
		path = devices[i].path;
        t.io.println("Connecting to " + devices[i].path);
        chrome.serial.connect(devices[i].path, connected_cb);
        return;
      }
      t.io.println(devices[i].path + ' ' + devices[i].displayName + ' ' + devices[i].vendorId + ' ' + devices[i].productId );
   }
   
   var test = w2ui['toolbar'].get('port');
   if(test.value){
		t.io.println('UD3 not found connect to: '+ test.value);
		chrome.serial.connect(test.value, connected_cb);
   }else{
	   t.io.println('No COM specified trying COM12');
	   chrome.serial.connect('COM12', connected_cb);
   }
   

}

function delay(ms) {
   ms += new Date().getTime();
   while (new Date() < ms){}
}

function connect(){
	if(connected){
		send_command('stmbl stop\rcls\r');
		delay(200);
		chrome.serial.disconnect(connid,disconnected_cb);
		w2ui['toolbar'].get('connect').text = 'Connect';
		w2ui['toolbar'].refresh();
		connected= false;
		
	}else{
		chrome.serial.getDevices(getdevs);
	}
}

function disconnected_cb(){
	t.io.println('disconnected');
}

function error(info){
	t.io.println(info.error);
	disconnect();
}

function disconnect(){
	chrome.serial.disconnect(connid,disconnected_cb);
	document.getElementById('connectbutton').value = "Connect";
	connected = false;
}



function clear(){
	t.io.print('\033[2J\033[0;0H');

}


function onexport(e){
   if(capture_active){
      capture_active = false;
      document.getElementById('exportbutton').value = "capture";
      chrome.fileSystem.chooseEntry({type: 'saveFile', suggestedName: "data.csv"}, function(writableFileEntry){
        writableFileEntry.createWriter(function(writer){
          writer.onerror = function(e){
             console.log('write error');
             data = "";
          };
          writer.onwriteend = function(e) {
             console.log('write complete');
             data = "";
          };
          writer.write(new Blob([data], {type: 'text/plain'}));
        });
      }
      );
   }
   else{
      capture_active = true;
      document.getElementById('exportbutton').value = "stop + export";
   }
}

const meas_space = 20;
var meas_position = 4;
const info_space = 150;
const control_space = 15;
const top_space = 20;
const TRIGGER_SPACE = 10;

function redrawInfo(){

  var ctx = wavecanvas.getContext('2d');
  var x_res = wavecanvas.width;
  var y_res = wavecanvas.height;
  var line_height = 16;
  var trigger_symbol = "";
  ctx.clearRect(x_res - info_space, 0, x_res, y_res - meas_space);
  ctx.font = "12px Arial";
  ctx.textAlign = "left";
  var tterm_length = tterm.length;
  for (var i = 0; i < tterm_length; i++){
    if (tterm[i].name){
      ctx.fillStyle = wavecolor[i];
      if(i == tterm.trigger){
        trigger_symbol = "->";
      }
      ctx.fillText(trigger_symbol + "Wave" + i + ": " + tterm[i].name,x_res - info_space + 4, line_height * (i+1));
      trigger_symbol = "";
    }
  }
}

function plot(){
	//TODO: multiple waves

   var x_res = wavecanvas.width-info_space;
   var y_res = wavecanvas.height-meas_space-top_space;

	var ctx = wavecanvas.getContext('2d');

  	ctx.clearRect(plotxpos, 0, pixel, y_res+top_space);

	//var i = 0;
	for(var i = 0;i<tterm.length;i++){
		var ypos = (tterm[i].value*-1+1)*(y_res/2.0);
		if(plotypos[i] && (plotypos[i] != (y_res/2.0) || tterm[i].value)){
			ctx.beginPath();
			ctx.lineWidth = pixel;
			ctx.strokeStyle = wavecolor[i];
			ctx.moveTo(plotxpos,plotypos[i]+top_space);
			ctx.lineTo(plotxpos+pixel,ypos+top_space);
			ctx.stroke();
		}
		plotypos[i] = ypos;//save previous position
	}

	plotxpos+=pixel;
	if(plotxpos>=x_res){
		/*if(trigger_enabled && !trigger_singleshot){
			trigger_buttonstate = 1;
			trigger_wait = true;
			for(var i = 0;i<value.length;i++){
				plotypos[i] = 0;
			}
		}
		*/
    plotxpos = 11;
	}
	
	
}

function redrawMeas(){

  var ctx = wavecanvas.getContext('2d');
  var x_res = wavecanvas.width;
  var y_res = wavecanvas.height;
  ctx.clearRect(TRIGGER_SPACE, y_res - meas_space, x_res - info_space, y_res);

  ctx.font = "12px Arial";
  ctx.textAlign = "left";
  ctx.fillStyle = "white"
  ctx.fillText("Trg lvl: " + tterm.trigger_lvl ,TRIGGER_SPACE, y_res - meas_position);
}




function resize(){
	// console.log("resize");

   //console.log(window.devicePixelRatio);
   plotxpos = 11;
   var canvas = document.getElementById('wavecanvas');
   var canvasback = document.getElementById('waveback');
   canvas.style.width=(100-control_space)+'%';
   canvas.style.height='100%';
   canvas.width  = canvas.offsetWidth;
   canvas.height = canvas.offsetHeight;
   canvasback.style.width=(100-control_space)+'%';
   canvasback.style.height='100%';
   canvasback.width  = canvas.offsetWidth;
   canvasback.height = canvas.offsetHeight;
   //HiDPI display support
   if(window.devicePixelRatio){
      pixel = window.devicePixelRatio;
      var height = canvas.getAttribute('height');
      var width = canvas.getAttribute('width');
      // reset the canvas width and height with window.devicePixelRatio applied
      canvas.setAttribute('width', Math.round(width * window.devicePixelRatio));
      canvas.setAttribute('height', Math.round( height * window.devicePixelRatio));
      canvasback.setAttribute('width', Math.round(width * window.devicePixelRatio));
      canvasback.setAttribute('height', Math.round( height * window.devicePixelRatio));
      // force the canvas back to the original size using css
      canvas.style.width = width+"px";
      canvas.style.height = height+"px";
      canvasback.style.width = width+"px";
      canvasback.style.height = height+"px";
   }

   var x_res = canvas.width-info_space;
   var y_res = canvas.height-meas_space-top_space;

   var ctxb = canvasback.getContext('2d');
	 ctxb.beginPath();
	 ctxb.strokeStyle= "yellow";
   ctxb.lineWidth = pixel;

   ctxb.moveTo(10, Math.floor(y_res/2)+top_space);
   ctxb.lineTo(x_res, Math.floor(y_res/2)+top_space);

   ctxb.stroke();

   ctxb.beginPath();
   ctxb.lineWidth = pixel;
   ctxb.strokeStyle= "yellow";
   ctxb.moveTo(11, top_space);
   ctxb.lineTo(11, y_res+top_space);
   ctxb.stroke();
   ctxb.beginPath();
   ctxb.lineWidth = pixel;
   ctxb.strokeStyle= "grey";
   for(var i = 10+grid; i < x_res; i=i+grid){
     ctxb.moveTo(i, top_space);
     ctxb.lineTo(i, y_res+top_space);
   }

   for(i = (y_res/2)+(y_res/10); i < y_res; i=i+(y_res/10)){
     ctxb.moveTo(10, i+top_space);
     ctxb.lineTo(x_res, i+top_space);
     ctxb.moveTo(10, y_res -i+top_space);
     ctxb.lineTo(x_res, y_res -i+top_space);
   }

   ctxb.stroke();

  // redrawTrigger();
   redrawMeas();
}

function send_command(command){
	chrome.serial.send(connid, convertStringToArrayBuffer(command), sendcb);
	console.log(command);
}

function sendfile(file){
   if(!connected){
      return;
   }
   var reader = new FileReader();
   reader.onload = function(progressEvent){
      // chrome.serial.send(connid, this.result, sendcb);
      var lines = this.result.split('\n');
      for(var line = 0; line < lines.length; line++){
            txqueue.push(lines[line]);
         }
      chrome.serial.send(connid, convertStringToArrayBuffer(txqueue.shift() + '\n'), sendcb);
   };
   reader.readAsText(file);
}

function ondrop(e){
   e.stopPropagation();
   e.preventDefault();
   if(e.dataTransfer.items.length == 1){//only one file
      sendfile(e.dataTransfer.files[0]);
   }
}

function ondragover(e){
   e.stopPropagation();
   e.preventDefault();
   e.dataTransfer.dropEffect = 'copy';
}

function warn_energ() {
    w2confirm('WARNING!<br>The coil will be energized.')
    .no(function () { })
	.yes(function () { send_command('bus on\r'); });
}

function warn_eeprom_save() {
    w2confirm('WARNING!<br>Are you sure to save the configuration to EEPROM?')
    .no(function () { })
	.yes(function () { send_command('eeprom save\r'); });
}
function warn_eeprom_load() {
    w2confirm('WARNING!<br>Are you sure to load the configuration from EEPROM?')
    .no(function () { })
	.yes(function () { send_command('eeprom load\r'); });
}

function wave_mouse_down(e){
	var pos_y = e.y - 51;
	var y_res = wavecanvas.height-meas_space-top_space;
	if(pos_y>=top_space && pos_y<=wavecanvas.height-meas_space){
		pos_y-=top_space;
		tterm.trigger_lvl=((2/y_res)*((y_res/2)-pos_y)).toFixed(2);
		redrawMeas();
		redrawTrigger();
	}
}

function redrawTrigger(){
  var ctx = wavecanvas.getContext('2d');
  var x_res = wavecanvas.width;
  var y_res = wavecanvas.height-meas_space-top_space;
  var ytrgpos = Math.floor((tterm.trigger_lvl*-1+1)*(y_res/2.0))+top_space;
  //trigger_lvl = document.getElementById("trglevel").value
  ctx.clearRect(0, 0, 10, wavecanvas.height);
 // if(trigger_enabled){
	if(1){
    ctx.beginPath();
    ctx.lineWidth = pixel;
    ctx.strokeStyle = wavecolor[1];
    ctx.moveTo(0, ytrgpos);
    ctx.lineTo(10, ytrgpos);
    ctx.moveTo(10, ytrgpos);
    if(tterm.trigger_lvl>0){
      ctx.lineTo(5, ytrgpos-2);
    }else{
      ctx.lineTo(5, ytrgpos+2);
    }
    ctx.stroke();
    ctx.font = "12px Arial";
    ctx.textAlign = "center";
    ctx.fillStyle = wavecolor[1];
    if(ytrgpos < 14){
      ctx.fillText(1,4,ytrgpos+12);
    }else{
      ctx.fillText(1,4,ytrgpos-4);
    }
  }
}




document.addEventListener('DOMContentLoaded', function () {

	$(function () {
    $('#toolbar').w2toolbar({
        name: 'toolbar',
        items: [
		    { type: 'menu', id: 'mnu_command', text: 'Commands', icon: 'fa fa-table', items: [
                { text: 'BUS ON', icon: 'fa fa-bolt'},
				{ text: 'BUS OFF', icon: 'fa fa-bolt'},
				{ text: 'Save EEPROM-Config', icon: 'fa fa-microchip'},
				{ text: 'Load EEPROM-Config', icon: 'fa fa-microchip'}
            ]},
            { type: 'spacer' },
			{ type: 'button', id: 'kill', text: 'KILL', icon: 'fa fa-power-off' },
			{ type: 'html',  id: 'port',
                html: function (item) {
                    var html =
                      '<div style="padding: 3px 10px;">'+
                      ' Port:'+
                      '    <input size="20" placeholder="COM1" onchange="var el = w2ui.toolbar.set(\'port\', { value: this.value });" '+
                      '         style="padding: 3px; border-radius: 2px; border: 1px solid silver" value="'+ (item.value || '') +'"/>'+
                      '</div>';
                    return html;
                }
            },
            { type: 'button', id: 'connect', text: 'Connect', icon: 'fa fa-plug' },
			{ type: 'button', id: 'cls', text: 'Clear Term', icon: 'fa fa-terminal' }
        ],
        onClick: function (event) {
            console.log('Target: '+ event.target, event);
			switch (event.target) {
		
                case 'connect':
                    connect();
					
                break;
				case 'cls':
                    clear();
                break;
				case 'mnu_command:BUS ON':
					warn_energ();
				break;
				case 'mnu_command:BUS OFF':
					send_command('bus off\r');
				break;
				case 'mnu_command:Load EEPROM-Config':
					warn_eeprom_load();
				break;
				case 'mnu_command:Save EEPROM-Config':
					warn_eeprom_save();
				break;
				case 'kill':
					send_command('kill\r');
				break;
            }
        }
    });
});
	

	var html_gauges='';
	for(var i=0;i<NUM_GAUGES;i++){
		html_gauges+='<div id="gauge'+ i +'" style= "width: 100px; height: 100px"></div>'
	}

	
	
	var pstyle = 'background-color: #F5F6F7;  padding: 5px;';
	$('#layout').w2layout({
		name: 'layout',
		panels: [
			{ type: 'top',  size: 50, overflow: "hidden", resizable: false, style: pstyle, content:
				'<div id="toolbar" style="padding: 4px; border: 1px solid #dfdfdf; border-radius: 3px"></div>'
			},
			{ type: 'main', style: pstyle, content:
				'<canvas id="waveback" style= "position: absolute; left: 0; top: 0; background: black; z-index: 0;"></canvas>'+
				'<canvas id="wavecanvas" style= "position: absolute; left: 0; top: 0;z-index: 1;"></canvas>' 
				//'<div id="lineChart" class="epoch category10" style="width: 100%; height: 100%"></div>'
			},
			{ type: 'right', size: 120, resizable: false, style: pstyle, content:
				(html_gauges)
			},
			
			{ type: 'preview'	, size: '50%', resizable: true, style: pstyle, content:
				'<div id="terminal" style="position:relative; width:100%; height:100%"></div>' 
			},

		]
	});


	w2ui['layout'].on({ type : 'resize', execute : 'after'}, function (target, eventData) {
		resize();
	});
	t.decorate(document.querySelector('#terminal'));
	t.installKeyboard();
	chrome.serial.onReceive.addListener(receive);
	chrome.serial.onReceiveError.addListener(error);
	document.getElementById('layout').addEventListener("drop", ondrop);
	document.getElementById('layout').addEventListener("dragover", ondragover);
	//document.getElementById('wavecanvas').addEventListener("onmousedown", wave_mouse_down);
	/*
	smoothie.streamTo(document.getElementById("wavecanvas"),500);
	smoothie.addTimeSeries(line[0], { strokeStyle:wavecolor[0], lineWidth:1 });
	smoothie.addTimeSeries(line[1], { strokeStyle:wavecolor[1], lineWidth:1 });
	smoothie.addTimeSeries(line[2], { strokeStyle:wavecolor[2], lineWidth:1 });
	smoothie.addTimeSeries(line[3], { strokeStyle:wavecolor[3], lineWidth:1 });
	
	
	lchart = $('#lineChart').epoch({
    type: 'line',
    data: data,
    axes: ['left', 'right', 'bottom'],
	fps: 60
	});
	*/
	
	wavecanvas = document.getElementById("wavecanvas");
	backcanvas = document.getElementById("wavecanvas");
	
	wavecanvas.onmousedown = wave_mouse_down;
    

	
	
	for(var i=0;i<NUM_GAUGES;i++){
		g[i]= new JustGage({
			id: ("gauge"+i),
			value: 255,
			min: 0,
			max: 255,
			title: ("Gauge"+i)
		});
		tterm.push({min: 0, max: 1024.0, offset: 1024.0, value: 0, name: ''});
	}
	tterm.push({trigger: 0});
	tterm.push({trigger_lvl: 0});

	
	
});
